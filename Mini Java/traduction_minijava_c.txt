/*
class Extends {
  public static void main(String[] args) {
    System.out.println(new A().init());
  }
}
class A {
  int a;
  public A get() {
    return new A();
  }
  public int init() {
    A a;
    A b;
    A c;
    int tmp;
    a = new A().get();
    b = new B().get();
    c = new C().get();
    tmp = a.print();
    tmp = b.print();
    tmp = c.print();
    return 0;
  }
  public int print() {
    System.out.println(65);
    return 65;
  }
}
class B extends A {
  int b;
  public B get() {
    return new B();
  }
  public int print() {
    System.out.println(66);
    return 66;
  }
}
class C extends B {
  public C get() {
    return new C();
  }
  public int print() {
    System.out.println(67);
    return 67;
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct A;
struct B;
struct C;
void* A_get(struct A* this);
void* A_init(struct A* this);
void* A_print(struct A* this);
void* B_get(struct B* this);
void* B_print(struct B* this);
void* C_get(struct C* this);
void* C_print(struct C* this);
struct A {
  void* (**vtable)();
  int _1;
};
struct B {
  void* (**vtable)();
  int _1;
  int _2;
};
struct C {
  void* (**vtable)();
  int _1;
  int _2;
};
void* (*A_vtable[])() = {A_get, A_init, A_print};
void* (*B_vtable[])() = {B_get, A_init, B_print};
void* (*C_vtable[])() = {C_get, A_init, C_print};
void* A_get(struct A* this) {
  return (void*)(({ struct A* tmp = (struct A*) calloc(1, sizeof(*tmp)); tmp->vtable = A_vtable; tmp; }));
}
void* A_init(struct A* this) {
  struct A* a;
  struct A* b;
  struct A* c;
  int tmp;
  a = ({ struct A* tmp = ({ struct A* tmp = (struct A*) calloc(1, sizeof(*tmp)); tmp->vtable = A_vtable; tmp; }); (struct A*) tmp->vtable[0](tmp); });
  b = (struct A*) ({ struct B* tmp = ({ struct B* tmp = (struct B*) calloc(1, sizeof(*tmp)); tmp->vtable = B_vtable; tmp; }); (struct B*) tmp->vtable[0](tmp); });
  c = (struct A*) ({ struct C* tmp = ({ struct C* tmp = (struct C*) calloc(1, sizeof(*tmp)); tmp->vtable = C_vtable; tmp; }); (struct C*) tmp->vtable[0](tmp); });
  tmp = ({ struct A* tmp = a; (int) tmp->vtable[2](tmp); });
  tmp = ({ struct A* tmp = b; (int) tmp->vtable[2](tmp); });
  tmp = ({ struct A* tmp = c; (int) tmp->vtable[2](tmp); });
  return (void*)(0);
}
void* A_print(struct A* this) {
  printf("%d\n", 65);
  return (void*)(65);
}
void* B_get(struct B* this) {
  return (void*)(({ struct B* tmp = (struct B*) calloc(1, sizeof(*tmp)); tmp->vtable = B_vtable; tmp; }));
}
void* B_print(struct B* this) {
  printf("%d\n", 66);
  return (void*)(66);
}
void* C_get(struct C* this) {
  return (void*)(({ struct C* tmp = (struct C*) calloc(1, sizeof(*tmp)); tmp->vtable = C_vtable; tmp; }));
}
void* C_print(struct C* this) {
  printf("%d\n", 67);
  return (void*)(67);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct A* tmp = ({ struct A* tmp = (struct A*) calloc(1, sizeof(*tmp)); tmp->vtable = A_vtable; tmp; }); (int) tmp->vtable[1](tmp); }));
  return 0;
}

/*
class Factorial {
  public static void main(String[] a) {
    System.out.println(new Fac().computeFac(10));
  }
}
class Fac {
  public int computeFac(int num) {
    int numAux;
    if (num < 1) numAux = 1;
    else numAux = num * this.computeFac(num - 1);
    return numAux;
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct Fac;
void* Fac_computeFac(struct Fac* this, int num);
struct Fac {
  void* (**vtable)();
};
void* (*Fac_vtable[])() = {Fac_computeFac};
void* Fac_computeFac(struct Fac* this, int num) {
  int numAux;
  if ((num < 1)) numAux = 1;
  else numAux = (num * ({ struct Fac* tmp = this; (int) tmp->vtable[0](tmp, (num - 1)); }));
  return (void*)(numAux);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct Fac* tmp = ({ struct Fac* tmp = (struct Fac*) calloc(1, sizeof(*tmp)); tmp->vtable = Fac_vtable; tmp; }); (int) tmp->vtable[0](tmp, 10); }));
  return 0;
}

/*
class Array {
  public static void main(String[] args) {
    System.out.println(new Main().init());
  }
}
class Main {
  public int[] createArray(int n) {
    int[] a;
    int i;
    a = new int[n];
    i = 0;
    while (i < n) {
      a[i] = i;
      i = i + 1;
    }
    return a;
  }
  public int init() {
    return this.createArray(42)[3];
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct Main;
void* Main_createArray(struct Main* this, int n);
void* Main_init(struct Main* this);
struct Main {
  void* (**vtable)();
};
void* (*Main_vtable[])() = {Main_createArray, Main_init};
void* Main_createArray(struct Main* this, int n) {
  struct array* a;
  int i;
  a = (void*)({ struct array* tmp = (struct array*) malloc(sizeof(struct array)); tmp->array = (int*) calloc(n, sizeof(int)); tmp->length = n; tmp; });
  i = 0;
  while ((i < n)) {
    (a)->array[i] = i;
    i = (i + 1);
  }
  return (void*)(a);
}
void* Main_init(struct Main* this) {
  return (void*)((({ struct Main* tmp = this; (struct array*) tmp->vtable[0](tmp, 42); }))->array[3]);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct Main* tmp = ({ struct Main* tmp = (struct Main*) calloc(1, sizeof(*tmp)); tmp->vtable = Main_vtable; tmp; }); (int) tmp->vtable[1](tmp); }));
  return 0;
}

/*
class Attributes {
  public static void main(String[] args) {
    System.out.println(new Main().start());
  }
}
class A {
  int a;
  public int draw() {
    System.out.println(a);
    return a;
  }
  public boolean init() {
    a = 65;
    return true;
  }
}
class B extends A {
  int a;
  public int draw() {
    System.out.println(a);
    return a;
  }
  public boolean init() {
    a = 66;
    return true;
  }
}
class C extends B {
  int a;
  public int draw() {
    System.out.println(a);
    return a;
  }
  public boolean init() {
    a = 67;
    return true;
  }
}
class Main {
  public int start() {
    A a;
    A b;
    A c;
    boolean tmp1;
    int tmp2;
    a = new A();
    tmp1 = a.init();
    b = new B();
    tmp1 = b.init();
    c = new C();
    tmp1 = c.init();
    tmp2 = a.draw();
    tmp2 = b.draw();
    tmp2 = c.draw();
    return 0;
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct A;
struct B;
struct C;
struct Main;
void* A_draw(struct A* this);
void* A_init(struct A* this);
void* B_draw(struct B* this);
void* B_init(struct B* this);
void* C_draw(struct C* this);
void* C_init(struct C* this);
void* Main_start(struct Main* this);
struct A {
  void* (**vtable)();
  int _1;
};
struct B {
  void* (**vtable)();
  int _1;
  int _2;
};
struct C {
  void* (**vtable)();
  int _1;
  int _2;
  int _3;
};
struct Main {
  void* (**vtable)();
};
void* (*A_vtable[])() = {A_draw, A_init};
void* (*B_vtable[])() = {B_draw, B_init};
void* (*C_vtable[])() = {C_draw, C_init};
void* (*Main_vtable[])() = {Main_start};
void* A_draw(struct A* this) {
  printf("%d\n", *((int*)((char*) this + 8)));
  return (void*)(*((int*)((char*) this + 8)));
}
void* A_init(struct A* this) {
  *((int*)((char*) this + 8)) = 65;
  return (void*)(1);
}
void* B_draw(struct B* this) {
  printf("%d\n", *((int*)((char*) this + 12)));
  return (void*)(*((int*)((char*) this + 12)));
}
void* B_init(struct B* this) {
  *((int*)((char*) this + 12)) = 66;
  return (void*)(1);
}
void* C_draw(struct C* this) {
  printf("%d\n", *((int*)((char*) this + 16)));
  return (void*)(*((int*)((char*) this + 16)));
}
void* C_init(struct C* this) {
  *((int*)((char*) this + 16)) = 67;
  return (void*)(1);
}
void* Main_start(struct Main* this) {
  struct A* a;
  struct A* b;
  struct A* c;
  int tmp1;
  int tmp2;
  a = ({ struct A* tmp = (struct A*) calloc(1, sizeof(*tmp)); tmp->vtable = A_vtable; tmp; });
  tmp1 = ({ struct A* tmp = a; (int) tmp->vtable[1](tmp); });
  b = (struct A*) ({ struct B* tmp = (struct B*) calloc(1, sizeof(*tmp)); tmp->vtable = B_vtable; tmp; });
  tmp1 = ({ struct A* tmp = b; (int) tmp->vtable[1](tmp); });
  c = (struct A*) ({ struct C* tmp = (struct C*) calloc(1, sizeof(*tmp)); tmp->vtable = C_vtable; tmp; });
  tmp1 = ({ struct A* tmp = c; (int) tmp->vtable[1](tmp); });
  tmp2 = ({ struct A* tmp = a; (int) tmp->vtable[0](tmp); });
  tmp2 = ({ struct A* tmp = b; (int) tmp->vtable[0](tmp); });
  tmp2 = ({ struct A* tmp = c; (int) tmp->vtable[0](tmp); });
  return (void*)(0);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct Main* tmp = ({ struct Main* tmp = (struct Main*) calloc(1, sizeof(*tmp)); tmp->vtable = Main_vtable; tmp; }); (int) tmp->vtable[0](tmp); }));
  return 0;
}

/*
class BinarySearch {
  public static void main(String[] a) {
    System.out.println(new BS().Start(20));
  }
}
class BS {
  int[] number;
  int size;
  public boolean Compare(int num1, int num2) {
    int aux02;
    boolean retval;
    retval = false;
    aux02 = num2 + 1;
    if (num1 < num2) retval = false;
    else if (!(num1 < aux02)) retval = false;
    else retval = true;
    return retval;
  }
  public int Div(int num) {
    int aux03;
    int count01;
    int count02;
    count01 = 0;
    count02 = 0;
    aux03 = num - 1;
    while (count02 < aux03) {
      count01 = count01 + 1;
      count02 = count02 + 2;
    }
    return count01;
  }
  public int Init(int sz) {
    int aux01;
    int aux02;
    int j;
    int k;
    size = sz;
    number = new int[sz];
    j = 1;
    k = size + 1;
    while (j < size) {
      aux01 = 2 * j;
      aux02 = k - 3;
      number[j] = aux01 + aux02;
      j = j + 1;
      k = k - 1;
    }
    return 0;
  }
  public int Print() {
    int j;
    j = 1;
    while (j < size) {
      System.out.println(number[j]);
      j = j + 1;
    }
    System.out.println(99999);
    return 0;
  }
  public boolean Search(int num) {
    int aux01;
    boolean bs01;
    int left;
    int medium;
    int nt;
    int right;
    boolean var_cont;
    aux01 = 0;
    bs01 = false;
    right = number.length;
    right = right - 1;
    left = 0;
    var_cont = true;
    while (var_cont) {
      medium = left + right;
      medium = this.Div(medium);
      aux01 = number[medium];
      if (num < aux01) right = medium - 1;
      else left = medium + 1;
      if (this.Compare(aux01, num)) var_cont = false;
      else var_cont = true;
      if (right < left) var_cont = false;
      else nt = 0;
    }
    if (this.Compare(aux01, num)) bs01 = true;
    else bs01 = false;
    return bs01;
  }
  public int Start(int sz) {
    int aux01;
    int aux02;
    aux01 = this.Init(sz);
    aux02 = this.Print();
    if (this.Search(8)) System.out.println(1);
    else System.out.println(0);
    if (this.Search(19)) System.out.println(1);
    else System.out.println(0);
    if (this.Search(20)) System.out.println(1);
    else System.out.println(0);
    if (this.Search(21)) System.out.println(1);
    else System.out.println(0);
    if (this.Search(37)) System.out.println(1);
    else System.out.println(0);
    if (this.Search(38)) System.out.println(1);
    else System.out.println(0);
    if (this.Search(39)) System.out.println(1);
    else System.out.println(0);
    if (this.Search(50)) System.out.println(1);
    else System.out.println(0);
    return 999;
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct BS;
void* BS_Compare(struct BS* this, int num1, int num2);
void* BS_Div(struct BS* this, int num);
void* BS_Init(struct BS* this, int sz);
void* BS_Print(struct BS* this);
void* BS_Search(struct BS* this, int num);
void* BS_Start(struct BS* this, int sz);
struct BS {
  void* (**vtable)();
  struct array* _1;
  int _2;
};
void* (*BS_vtable[])() = {BS_Compare, BS_Div, BS_Init, BS_Print, BS_Search, BS_Start};
void* BS_Compare(struct BS* this, int num1, int num2) {
  int aux02;
  int retval;
  retval = 0;
  aux02 = (num2 + 1);
  if ((num1 < num2)) retval = 0;
  else if (!((num1 < aux02))) retval = 0;
  else retval = 1;
  return (void*)(retval);
}
void* BS_Div(struct BS* this, int num) {
  int aux03;
  int count01;
  int count02;
  count01 = 0;
  count02 = 0;
  aux03 = (num - 1);
  while ((count02 < aux03)) {
    count01 = (count01 + 1);
    count02 = (count02 + 2);
  }
  return (void*)(count01);
}
void* BS_Init(struct BS* this, int sz) {
  int aux01;
  int aux02;
  int j;
  int k;
  *((int*)((char*) this + 16)) = sz;
  *((struct array**)((char*) this + 8)) = (void*)({ struct array* tmp = (struct array*) malloc(sizeof(struct array)); tmp->array = (int*) calloc(sz, sizeof(int)); tmp->length = sz; tmp; });
  j = 1;
  k = (*((int*)((char*) this + 16)) + 1);
  while ((j < *((int*)((char*) this + 16)))) {
    aux01 = (2 * j);
    aux02 = (k - 3);
    (*((struct array**)((char*) this + 8)))->array[j] = (aux01 + aux02);
    j = (j + 1);
    k = (k - 1);
  }
  return (void*)(0);
}
void* BS_Print(struct BS* this) {
  int j;
  j = 1;
  while ((j < *((int*)((char*) this + 16)))) {
    printf("%d\n", (*((struct array**)((char*) this + 8)))->array[j]);
    j = (j + 1);
  }
  printf("%d\n", 99999);
  return (void*)(0);
}
void* BS_Search(struct BS* this, int num) {
  int aux01;
  int bs01;
  int left;
  int medium;
  int nt;
  int right;
  int var_cont;
  aux01 = 0;
  bs01 = 0;
  right = (*((struct array**)((char*) this + 8)))->length;
  right = (right - 1);
  left = 0;
  var_cont = 1;
  while (var_cont) {
    medium = (left + right);
    medium = ({ struct BS* tmp = this; (int) tmp->vtable[1](tmp, medium); });
    aux01 = (*((struct array**)((char*) this + 8)))->array[medium];
    if ((num < aux01)) right = (medium - 1);
    else left = (medium + 1);
    if (({ struct BS* tmp = this; (int) tmp->vtable[0](tmp, aux01, num); })) var_cont = 0;
    else var_cont = 1;
    if ((right < left)) var_cont = 0;
    else nt = 0;
  }
  if (({ struct BS* tmp = this; (int) tmp->vtable[0](tmp, aux01, num); })) bs01 = 1;
  else bs01 = 0;
  return (void*)(bs01);
}
void* BS_Start(struct BS* this, int sz) {
  int aux01;
  int aux02;
  aux01 = ({ struct BS* tmp = this; (int) tmp->vtable[2](tmp, sz); });
  aux02 = ({ struct BS* tmp = this; (int) tmp->vtable[3](tmp); });
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 8); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 19); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 20); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 21); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 37); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 38); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 39); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  if (({ struct BS* tmp = this; (int) tmp->vtable[4](tmp, 50); })) printf("%d\n", 1);
  else printf("%d\n", 0);
  return (void*)(999);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct BS* tmp = ({ struct BS* tmp = (struct BS*) calloc(1, sizeof(*tmp)); tmp->vtable = BS_vtable; tmp; }); (int) tmp->vtable[5](tmp, 20); }));
  return 0;
}

/*
class BubbleSort {
  public static void main(String[] a) {
    System.out.println(new BBS().Start(10));
  }
}
class BBS {
  int[] number;
  int size;
  public int Init(int sz) {
    size = sz;
    number = new int[sz];
    number[0] = 20;
    number[1] = 7;
    number[2] = 12;
    number[3] = 18;
    number[4] = 2;
    number[5] = 11;
    number[6] = 6;
    number[7] = 9;
    number[8] = 19;
    number[9] = 5;
    return 0;
  }
  public int Print() {
    int j;
    j = 0;
    while (j < size) {
      System.out.println(number[j]);
      j = j + 1;
    }
    return 0;
  }
  public int Sort() {
    int aux02;
    int aux04;
    int aux05;
    int aux06;
    int aux07;
    int i;
    int j;
    int nt;
    int t;
    i = size - 1;
    aux02 = 0 - 1;
    while (aux02 < i) {
      j = 1;
      while (j < i + 1) {
        aux07 = j - 1;
        aux04 = number[aux07];
        aux05 = number[j];
        if (aux05 < aux04) {
          aux06 = j - 1;
          t = number[aux06];
          number[aux06] = number[j];
          number[j] = t;
        }
        else nt = 0;
        j = j + 1;
      }
      i = i - 1;
    }
    return 0;
  }
  public int Start(int sz) {
    int aux01;
    aux01 = this.Init(sz);
    aux01 = this.Print();
    System.out.println(99999);
    aux01 = this.Sort();
    aux01 = this.Print();
    return 0;
  }
}
class array {
}
class array_ {
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array__ { int* array; int length; };
struct BBS;
struct array;
struct array_;
void* BBS_Init(struct BBS* this, int sz);
void* BBS_Print(struct BBS* this);
void* BBS_Sort(struct BBS* this);
void* BBS_Start(struct BBS* this, int sz);
struct BBS {
  void* (**vtable)();
  struct array__* _1;
  int _2;
};
struct array {
  void* (**vtable)();
};
struct array_ {
  void* (**vtable)();
};
void* (*BBS_vtable[])() = {BBS_Init, BBS_Print, BBS_Sort, BBS_Start};
void* (*array_vtable[])() = {};
void* (*array__vtable[])() = {};
void* BBS_Init(struct BBS* this, int sz) {
  *((int*)((char*) this + 16)) = sz;
  *((struct array__**)((char*) this + 8)) = (void*)({ struct array__* tmp = (struct array__*) malloc(sizeof(struct array__)); tmp->array = (int*) calloc(sz, sizeof(int)); tmp->length = sz; tmp; });
  (*((struct array__**)((char*) this + 8)))->array[0] = 20;
  (*((struct array__**)((char*) this + 8)))->array[1] = 7;
  (*((struct array__**)((char*) this + 8)))->array[2] = 12;
  (*((struct array__**)((char*) this + 8)))->array[3] = 18;
  (*((struct array__**)((char*) this + 8)))->array[4] = 2;
  (*((struct array__**)((char*) this + 8)))->array[5] = 11;
  (*((struct array__**)((char*) this + 8)))->array[6] = 6;
  (*((struct array__**)((char*) this + 8)))->array[7] = 9;
  (*((struct array__**)((char*) this + 8)))->array[8] = 19;
  (*((struct array__**)((char*) this + 8)))->array[9] = 5;
  return (void*)(0);
}
void* BBS_Print(struct BBS* this) {
  int j;
  j = 0;
  while ((j < *((int*)((char*) this + 16)))) {
    printf("%d\n", (*((struct array__**)((char*) this + 8)))->array[j]);
    j = (j + 1);
  }
  return (void*)(0);
}
void* BBS_Sort(struct BBS* this) {
  int aux02;
  int aux04;
  int aux05;
  int aux06;
  int aux07;
  int i;
  int j;
  int nt;
  int t;
  i = (*((int*)((char*) this + 16)) - 1);
  aux02 = (0 - 1);
  while ((aux02 < i)) {
    j = 1;
    while ((j < (i + 1))) {
      aux07 = (j - 1);
      aux04 = (*((struct array__**)((char*) this + 8)))->array[aux07];
      aux05 = (*((struct array__**)((char*) this + 8)))->array[j];
      if ((aux05 < aux04)) {
        aux06 = (j - 1);
        t = (*((struct array__**)((char*) this + 8)))->array[aux06];
        (*((struct array__**)((char*) this + 8)))->array[aux06] = (*((struct array__**)((char*) this + 8)))->array[j];
        (*((struct array__**)((char*) this + 8)))->array[j] = t;
      }
      else nt = 0;
      j = (j + 1);
    }
    i = (i - 1);
  }
  return (void*)(0);
}
void* BBS_Start(struct BBS* this, int sz) {
  int aux01;
  aux01 = ({ struct BBS* tmp = this; (int) tmp->vtable[0](tmp, sz); });
  aux01 = ({ struct BBS* tmp = this; (int) tmp->vtable[1](tmp); });
  printf("%d\n", 99999);
  aux01 = ({ struct BBS* tmp = this; (int) tmp->vtable[2](tmp); });
  aux01 = ({ struct BBS* tmp = this; (int) tmp->vtable[1](tmp); });
  return (void*)(0);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct BBS* tmp = ({ struct BBS* tmp = (struct BBS*) calloc(1, sizeof(*tmp)); tmp->vtable = BBS_vtable; tmp; }); (int) tmp->vtable[3](tmp, 10); }));
  return 0;
}

/*
class LinearSearch {
  public static void main(String[] a) {
    System.out.println(new LS().Start(10));
  }
}
class LS {
  int[] number;
  int size;
  public int Init(int sz) {
    int aux01;
    int aux02;
    int j;
    int k;
    size = sz;
    number = new int[sz];
    j = 1;
    k = size + 1;
    while (j < size) {
      aux01 = 2 * j;
      aux02 = k - 3;
      number[j] = aux01 + aux02;
      j = j + 1;
      k = k - 1;
    }
    return 0;
  }
  public int Print() {
    int j;
    j = 1;
    while (j < size) {
      System.out.println(number[j]);
      j = j + 1;
    }
    return 0;
  }
  public int Search(int num) {
    int aux01;
    int aux02;
    int ifound;
    int j;
    boolean ls01;
    int nt;
    j = 1;
    ls01 = false;
    ifound = 0;
    while (j < size) {
      aux01 = number[j];
      aux02 = num + 1;
      if (aux01 < num) nt = 0;
      else if (!(aux01 < aux02)) nt = 0;
      else {
        ls01 = true;
        ifound = 1;
        j = size;
      }
      j = j + 1;
    }
    return ifound;
  }
  public int Start(int sz) {
    int aux01;
    int aux02;
    aux01 = this.Init(sz);
    aux02 = this.Print();
    System.out.println(9999);
    System.out.println(this.Search(8));
    System.out.println(this.Search(12));
    System.out.println(this.Search(17));
    System.out.println(this.Search(50));
    return 55;
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct LS;
void* LS_Init(struct LS* this, int sz);
void* LS_Print(struct LS* this);
void* LS_Search(struct LS* this, int num);
void* LS_Start(struct LS* this, int sz);
struct LS {
  void* (**vtable)();
  struct array* _1;
  int _2;
};
void* (*LS_vtable[])() = {LS_Init, LS_Print, LS_Search, LS_Start};
void* LS_Init(struct LS* this, int sz) {
  int aux01;
  int aux02;
  int j;
  int k;
  *((int*)((char*) this + 16)) = sz;
  *((struct array**)((char*) this + 8)) = (void*)({ struct array* tmp = (struct array*) malloc(sizeof(struct array)); tmp->array = (int*) calloc(sz, sizeof(int)); tmp->length = sz; tmp; });
  j = 1;
  k = (*((int*)((char*) this + 16)) + 1);
  while ((j < *((int*)((char*) this + 16)))) {
    aux01 = (2 * j);
    aux02 = (k - 3);
    (*((struct array**)((char*) this + 8)))->array[j] = (aux01 + aux02);
    j = (j + 1);
    k = (k - 1);
  }
  return (void*)(0);
}
void* LS_Print(struct LS* this) {
  int j;
  j = 1;
  while ((j < *((int*)((char*) this + 16)))) {
    printf("%d\n", (*((struct array**)((char*) this + 8)))->array[j]);
    j = (j + 1);
  }
  return (void*)(0);
}
void* LS_Search(struct LS* this, int num) {
  int aux01;
  int aux02;
  int ifound;
  int j;
  int ls01;
  int nt;
  j = 1;
  ls01 = 0;
  ifound = 0;
  while ((j < *((int*)((char*) this + 16)))) {
    aux01 = (*((struct array**)((char*) this + 8)))->array[j];
    aux02 = (num + 1);
    if ((aux01 < num)) nt = 0;
    else if (!((aux01 < aux02))) nt = 0;
    else {
      ls01 = 1;
      ifound = 1;
      j = *((int*)((char*) this + 16));
    }
    j = (j + 1);
  }
  return (void*)(ifound);
}
void* LS_Start(struct LS* this, int sz) {
  int aux01;
  int aux02;
  aux01 = ({ struct LS* tmp = this; (int) tmp->vtable[0](tmp, sz); });
  aux02 = ({ struct LS* tmp = this; (int) tmp->vtable[1](tmp); });
  printf("%d\n", 9999);
  printf("%d\n", ({ struct LS* tmp = this; (int) tmp->vtable[2](tmp, 8); }));
  printf("%d\n", ({ struct LS* tmp = this; (int) tmp->vtable[2](tmp, 12); }));
  printf("%d\n", ({ struct LS* tmp = this; (int) tmp->vtable[2](tmp, 17); }));
  printf("%d\n", ({ struct LS* tmp = this; (int) tmp->vtable[2](tmp, 50); }));
  return (void*)(55);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct LS* tmp = ({ struct LS* tmp = (struct LS*) calloc(1, sizeof(*tmp)); tmp->vtable = LS_vtable; tmp; }); (int) tmp->vtable[3](tmp, 10); }));
  return 0;
}

/*
class TreeVisitor {
  public static void main(String[] a) {
    System.out.println(new TV().Start());
  }
}
class MyVisitor extends Visitor {
  public int visit(Tree n) {
    int nti;
    if (n.GetHas_Right()) {
      r = n.GetRight();
      nti = r.accept(this);
    }
    else nti = 0;
    System.out.println(n.GetKey());
    if (n.GetHas_Left()) {
      l = n.GetLeft();
      nti = l.accept(this);
    }
    else nti = 0;
    return 0;
  }
}
class TV {
  public int Start() {
    boolean ntb;
    int nti;
    Tree root;
    MyVisitor v;
    root = new Tree();
    ntb = root.Init(16);
    ntb = root.Print();
    System.out.println(100000000);
    ntb = root.Insert(8);
    ntb = root.Insert(24);
    ntb = root.Insert(4);
    ntb = root.Insert(12);
    ntb = root.Insert(20);
    ntb = root.Insert(28);
    ntb = root.Insert(14);
    ntb = root.Print();
    System.out.println(100000000);
    v = new MyVisitor();
    System.out.println(50000000);
    nti = root.accept(v);
    System.out.println(100000000);
    System.out.println(root.Search(24));
    System.out.println(root.Search(12));
    System.out.println(root.Search(16));
    System.out.println(root.Search(50));
    System.out.println(root.Search(12));
    ntb = root.Delete(12);
    ntb = root.Print();
    System.out.println(root.Search(12));
    return 0;
  }
}
class Tree {
  boolean has_left;
  boolean has_right;
  int key;
  Tree left;
  Tree my_null;
  Tree right;
  public boolean Compare(int num1, int num2) {
    boolean ntb;
    int nti;
    ntb = false;
    nti = num2 + 1;
    if (num1 < num2) ntb = false;
    else if (!(num1 < nti)) ntb = false;
    else ntb = true;
    return ntb;
  }
  public boolean Delete(int v_key) {
    boolean cont;
    Tree current_node;
    boolean found;
    boolean is_root;
    int key_aux;
    boolean ntb;
    Tree parent_node;
    current_node = this;
    parent_node = this;
    cont = true;
    found = false;
    is_root = true;
    while (cont) {
      key_aux = current_node.GetKey();
      if (v_key < key_aux) if (current_node.GetHas_Left()) {
        parent_node = current_node;
        current_node = current_node.GetLeft();
      }
      else cont = false;
      else if (key_aux < v_key) if (current_node.GetHas_Right()) {
        parent_node = current_node;
        current_node = current_node.GetRight();
      }
      else cont = false;
      else {
        if (is_root) if (!current_node.GetHas_Right() && !current_node.GetHas_Left()) ntb = true;
        else ntb = this.Remove(parent_node, current_node);
        else ntb = this.Remove(parent_node, current_node);
        found = true;
        cont = false;
      }
      is_root = false;
    }
    return found;
  }
  public boolean GetHas_Left() {
    return has_left;
  }
  public boolean GetHas_Right() {
    return has_right;
  }
  public int GetKey() {
    return key;
  }
  public Tree GetLeft() {
    return left;
  }
  public Tree GetRight() {
    return right;
  }
  public boolean Init(int v_key) {
    key = v_key;
    has_left = false;
    has_right = false;
    return true;
  }
  public boolean Insert(int v_key) {
    boolean cont;
    Tree current_node;
    int key_aux;
    Tree new_node;
    boolean ntb;
    new_node = new Tree();
    ntb = new_node.Init(v_key);
    current_node = this;
    cont = true;
    while (cont) {
      key_aux = current_node.GetKey();
      if (v_key < key_aux) {
        if (current_node.GetHas_Left()) current_node = current_node.GetLeft();
        else {
          cont = false;
          ntb = current_node.SetHas_Left(true);
          ntb = current_node.SetLeft(new_node);
        }
      }
      else {
        if (current_node.GetHas_Right()) current_node = current_node.GetRight();
        else {
          cont = false;
          ntb = current_node.SetHas_Right(true);
          ntb = current_node.SetRight(new_node);
        }
      }
    }
    return true;
  }
  public boolean Print() {
    Tree current_node;
    boolean ntb;
    current_node = this;
    ntb = this.RecPrint(current_node);
    return true;
  }
  public boolean RecPrint(Tree node) {
    boolean ntb;
    if (node.GetHas_Left()) {
      ntb = this.RecPrint(node.GetLeft());
    }
    else ntb = true;
    System.out.println(node.GetKey());
    if (node.GetHas_Right()) {
      ntb = this.RecPrint(node.GetRight());
    }
    else ntb = true;
    return true;
  }
  public boolean Remove(Tree p_node, Tree c_node) {
    int auxkey1;
    int auxkey2;
    boolean ntb;
    if (c_node.GetHas_Left()) ntb = this.RemoveLeft(p_node, c_node);
    else if (c_node.GetHas_Right()) ntb = this.RemoveRight(p_node, c_node);
    else {
      auxkey1 = c_node.GetKey();
      auxkey2 = p_node.GetLeft().GetKey();
      if (this.Compare(auxkey1, auxkey2)) {
        ntb = p_node.SetLeft(my_null);
        ntb = p_node.SetHas_Left(false);
      }
      else {
        ntb = p_node.SetRight(my_null);
        ntb = p_node.SetHas_Right(false);
      }
    }
    return true;
  }
  public boolean RemoveLeft(Tree p_node, Tree c_node) {
    boolean ntb;
    while (c_node.GetHas_Left()) {
      ntb = c_node.SetKey(c_node.GetLeft().GetKey());
      p_node = c_node;
      c_node = c_node.GetLeft();
    }
    ntb = p_node.SetLeft(my_null);
    ntb = p_node.SetHas_Left(false);
    return true;
  }
  public boolean RemoveRight(Tree p_node, Tree c_node) {
    boolean ntb;
    while (c_node.GetHas_Right()) {
      ntb = c_node.SetKey(c_node.GetRight().GetKey());
      p_node = c_node;
      c_node = c_node.GetRight();
    }
    ntb = p_node.SetRight(my_null);
    ntb = p_node.SetHas_Right(false);
    return true;
  }
  public int Search(int v_key) {
    boolean cont;
    Tree current_node;
    int ifound;
    int key_aux;
    current_node = this;
    cont = true;
    ifound = 0;
    while (cont) {
      key_aux = current_node.GetKey();
      if (v_key < key_aux) if (current_node.GetHas_Left()) current_node = current_node.GetLeft();
      else cont = false;
      else if (key_aux < v_key) if (current_node.GetHas_Right()) current_node = current_node.GetRight();
      else cont = false;
      else {
        ifound = 1;
        cont = false;
      }
    }
    return ifound;
  }
  public boolean SetHas_Left(boolean val) {
    has_left = val;
    return true;
  }
  public boolean SetHas_Right(boolean val) {
    has_right = val;
    return true;
  }
  public boolean SetKey(int v_key) {
    key = v_key;
    return true;
  }
  public boolean SetLeft(Tree ln) {
    left = ln;
    return true;
  }
  public boolean SetRight(Tree rn) {
    right = rn;
    return true;
  }
  public int accept(Visitor v) {
    int nti;
    System.out.println(333);
    nti = v.visit(this);
    return 0;
  }
}
class Visitor {
  Tree l;
  Tree r;
  public int visit(Tree n) {
    int nti;
    if (n.GetHas_Right()) {
      r = n.GetRight();
      nti = r.accept(this);
    }
    else nti = 0;
    if (n.GetHas_Left()) {
      l = n.GetLeft();
      nti = l.accept(this);
    }
    else nti = 0;
    return 0;
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct MyVisitor;
struct TV;
struct Tree;
struct Visitor;
void* MyVisitor_visit(struct MyVisitor* this, struct Tree* n);
void* TV_Start(struct TV* this);
void* Tree_Compare(struct Tree* this, int num1, int num2);
void* Tree_Delete(struct Tree* this, int v_key);
void* Tree_GetHas_Left(struct Tree* this);
void* Tree_GetHas_Right(struct Tree* this);
void* Tree_GetKey(struct Tree* this);
void* Tree_GetLeft(struct Tree* this);
void* Tree_GetRight(struct Tree* this);
void* Tree_Init(struct Tree* this, int v_key);
void* Tree_Insert(struct Tree* this, int v_key);
void* Tree_Print(struct Tree* this);
void* Tree_RecPrint(struct Tree* this, struct Tree* node);
void* Tree_Remove(struct Tree* this, struct Tree* p_node, struct Tree* c_node);
void* Tree_RemoveLeft(struct Tree* this, struct Tree* p_node, struct Tree* c_node);
void* Tree_RemoveRight(struct Tree* this, struct Tree* p_node, struct Tree* c_node);
void* Tree_Search(struct Tree* this, int v_key);
void* Tree_SetHas_Left(struct Tree* this, int val);
void* Tree_SetHas_Right(struct Tree* this, int val);
void* Tree_SetKey(struct Tree* this, int v_key);
void* Tree_SetLeft(struct Tree* this, struct Tree* ln);
void* Tree_SetRight(struct Tree* this, struct Tree* rn);
void* Tree_accept(struct Tree* this, struct Visitor* v);
void* Visitor_visit(struct Visitor* this, struct Tree* n);
struct MyVisitor {
  void* (**vtable)();
  struct Tree* _1;
  struct Tree* _2;
};
struct TV {
  void* (**vtable)();
};
struct Tree {
  void* (**vtable)();
  int _1;
  int _2;
  int _3;
  struct Tree* _4;
  struct Tree* _5;
  struct Tree* _6;
};
struct Visitor {
  void* (**vtable)();
  struct Tree* _1;
  struct Tree* _2;
};
void* (*MyVisitor_vtable[])() = {MyVisitor_visit};
void* (*TV_vtable[])() = {TV_Start};
void* (*Tree_vtable[])() = {Tree_Compare, Tree_Delete, Tree_GetHas_Left, Tree_GetHas_Right, Tree_GetKey, Tree_GetLeft, Tree_GetRight, Tree_Init, Tree_Insert, Tree_Print, Tree_RecPrint, Tree_Remove, Tree_RemoveLeft, Tree_RemoveRight, Tree_Search, Tree_SetHas_Left, Tree_SetHas_Right, Tree_SetKey, Tree_SetLeft, Tree_SetRight, Tree_accept};
void* (*Visitor_vtable[])() = {Visitor_visit};
void* MyVisitor_visit(struct MyVisitor* this, struct Tree* n) {
  int nti;
  if (({ struct Tree* tmp = n; (int) tmp->vtable[3](tmp); })) {
    *((struct Tree**)((char*) this + 16)) = ({ struct Tree* tmp = n; (struct Tree*) tmp->vtable[6](tmp); });
    nti = ({ struct Tree* tmp = *((struct Tree**)((char*) this + 16)); (int) tmp->vtable[20](tmp, this); });
  }
  else nti = 0;
  printf("%d\n", ({ struct Tree* tmp = n; (int) tmp->vtable[4](tmp); }));
  if (({ struct Tree* tmp = n; (int) tmp->vtable[2](tmp); })) {
    *((struct Tree**)((char*) this + 8)) = ({ struct Tree* tmp = n; (struct Tree*) tmp->vtable[5](tmp); });
    nti = ({ struct Tree* tmp = *((struct Tree**)((char*) this + 8)); (int) tmp->vtable[20](tmp, this); });
  }
  else nti = 0;
  return (void*)(0);
}
void* TV_Start(struct TV* this) {
  int ntb;
  int nti;
  struct Tree* root;
  struct MyVisitor* v;
  root = ({ struct Tree* tmp = (struct Tree*) calloc(1, sizeof(*tmp)); tmp->vtable = Tree_vtable; tmp; });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[7](tmp, 16); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[9](tmp); });
  printf("%d\n", 100000000);
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[8](tmp, 8); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[8](tmp, 24); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[8](tmp, 4); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[8](tmp, 12); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[8](tmp, 20); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[8](tmp, 28); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[8](tmp, 14); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[9](tmp); });
  printf("%d\n", 100000000);
  v = ({ struct MyVisitor* tmp = (struct MyVisitor*) calloc(1, sizeof(*tmp)); tmp->vtable = MyVisitor_vtable; tmp; });
  printf("%d\n", 50000000);
  nti = ({ struct Tree* tmp = root; (int) tmp->vtable[20](tmp, v); });
  printf("%d\n", 100000000);
  printf("%d\n", ({ struct Tree* tmp = root; (int) tmp->vtable[14](tmp, 24); }));
  printf("%d\n", ({ struct Tree* tmp = root; (int) tmp->vtable[14](tmp, 12); }));
  printf("%d\n", ({ struct Tree* tmp = root; (int) tmp->vtable[14](tmp, 16); }));
  printf("%d\n", ({ struct Tree* tmp = root; (int) tmp->vtable[14](tmp, 50); }));
  printf("%d\n", ({ struct Tree* tmp = root; (int) tmp->vtable[14](tmp, 12); }));
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[1](tmp, 12); });
  ntb = ({ struct Tree* tmp = root; (int) tmp->vtable[9](tmp); });
  printf("%d\n", ({ struct Tree* tmp = root; (int) tmp->vtable[14](tmp, 12); }));
  return (void*)(0);
}
void* Tree_Compare(struct Tree* this, int num1, int num2) {
  int ntb;
  int nti;
  ntb = 0;
  nti = (num2 + 1);
  if ((num1 < num2)) ntb = 0;
  else if (!((num1 < nti))) ntb = 0;
  else ntb = 1;
  return (void*)(ntb);
}
void* Tree_Delete(struct Tree* this, int v_key) {
  int cont;
  struct Tree* current_node;
  int found;
  int is_root;
  int key_aux;
  int ntb;
  struct Tree* parent_node;
  current_node = this;
  parent_node = this;
  cont = 1;
  found = 0;
  is_root = 1;
  while (cont) {
    key_aux = ({ struct Tree* tmp = current_node; (int) tmp->vtable[4](tmp); });
    if ((v_key < key_aux)) if (({ struct Tree* tmp = current_node; (int) tmp->vtable[2](tmp); })) {
      parent_node = current_node;
      current_node = ({ struct Tree* tmp = current_node; (struct Tree*) tmp->vtable[5](tmp); });
    }
    else cont = 0;
    else if ((key_aux < v_key)) if (({ struct Tree* tmp = current_node; (int) tmp->vtable[3](tmp); })) {
      parent_node = current_node;
      current_node = ({ struct Tree* tmp = current_node; (struct Tree*) tmp->vtable[6](tmp); });
    }
    else cont = 0;
    else {
      if (is_root) if ((!(({ struct Tree* tmp = current_node; (int) tmp->vtable[3](tmp); })) && !(({ struct Tree* tmp = current_node; (int) tmp->vtable[2](tmp); })))) ntb = 1;
      else ntb = ({ struct Tree* tmp = this; (int) tmp->vtable[11](tmp, parent_node, current_node); });
      else ntb = ({ struct Tree* tmp = this; (int) tmp->vtable[11](tmp, parent_node, current_node); });
      found = 1;
      cont = 0;
    }
    is_root = 0;
  }
  return (void*)(found);
}
void* Tree_GetHas_Left(struct Tree* this) {
  return (void*)(*((int*)((char*) this + 8)));
}
void* Tree_GetHas_Right(struct Tree* this) {
  return (void*)(*((int*)((char*) this + 12)));
}
void* Tree_GetKey(struct Tree* this) {
  return (void*)(*((int*)((char*) this + 16)));
}
void* Tree_GetLeft(struct Tree* this) {
  return (void*)(*((struct Tree**)((char*) this + 20)));
}
void* Tree_GetRight(struct Tree* this) {
  return (void*)(*((struct Tree**)((char*) this + 36)));
}
void* Tree_Init(struct Tree* this, int v_key) {
  *((int*)((char*) this + 16)) = v_key;
  *((int*)((char*) this + 8)) = 0;
  *((int*)((char*) this + 12)) = 0;
  return (void*)(1);
}
void* Tree_Insert(struct Tree* this, int v_key) {
  int cont;
  struct Tree* current_node;
  int key_aux;
  struct Tree* new_node;
  int ntb;
  new_node = ({ struct Tree* tmp = (struct Tree*) calloc(1, sizeof(*tmp)); tmp->vtable = Tree_vtable; tmp; });
  ntb = ({ struct Tree* tmp = new_node; (int) tmp->vtable[7](tmp, v_key); });
  current_node = this;
  cont = 1;
  while (cont) {
    key_aux = ({ struct Tree* tmp = current_node; (int) tmp->vtable[4](tmp); });
    if ((v_key < key_aux)) {
      if (({ struct Tree* tmp = current_node; (int) tmp->vtable[2](tmp); })) current_node = ({ struct Tree* tmp = current_node; (struct Tree*) tmp->vtable[5](tmp); });
      else {
        cont = 0;
        ntb = ({ struct Tree* tmp = current_node; (int) tmp->vtable[15](tmp, 1); });
        ntb = ({ struct Tree* tmp = current_node; (int) tmp->vtable[18](tmp, new_node); });
      }
    }
    else {
      if (({ struct Tree* tmp = current_node; (int) tmp->vtable[3](tmp); })) current_node = ({ struct Tree* tmp = current_node; (struct Tree*) tmp->vtable[6](tmp); });
      else {
        cont = 0;
        ntb = ({ struct Tree* tmp = current_node; (int) tmp->vtable[16](tmp, 1); });
        ntb = ({ struct Tree* tmp = current_node; (int) tmp->vtable[19](tmp, new_node); });
      }
    }
  }
  return (void*)(1);
}
void* Tree_Print(struct Tree* this) {
  struct Tree* current_node;
  int ntb;
  current_node = this;
  ntb = ({ struct Tree* tmp = this; (int) tmp->vtable[10](tmp, current_node); });
  return (void*)(1);
}
void* Tree_RecPrint(struct Tree* this, struct Tree* node) {
  int ntb;
  if (({ struct Tree* tmp = node; (int) tmp->vtable[2](tmp); })) {
    ntb = ({ struct Tree* tmp = this; (int) tmp->vtable[10](tmp, ({ struct Tree* tmp = node; (struct Tree*) tmp->vtable[5](tmp); })); });
  }
  else ntb = 1;
  printf("%d\n", ({ struct Tree* tmp = node; (int) tmp->vtable[4](tmp); }));
  if (({ struct Tree* tmp = node; (int) tmp->vtable[3](tmp); })) {
    ntb = ({ struct Tree* tmp = this; (int) tmp->vtable[10](tmp, ({ struct Tree* tmp = node; (struct Tree*) tmp->vtable[6](tmp); })); });
  }
  else ntb = 1;
  return (void*)(1);
}
void* Tree_Remove(struct Tree* this, struct Tree* p_node, struct Tree* c_node) {
  int auxkey1;
  int auxkey2;
  int ntb;
  if (({ struct Tree* tmp = c_node; (int) tmp->vtable[2](tmp); })) ntb = ({ struct Tree* tmp = this; (int) tmp->vtable[12](tmp, p_node, c_node); });
  else if (({ struct Tree* tmp = c_node; (int) tmp->vtable[3](tmp); })) ntb = ({ struct Tree* tmp = this; (int) tmp->vtable[13](tmp, p_node, c_node); });
  else {
    auxkey1 = ({ struct Tree* tmp = c_node; (int) tmp->vtable[4](tmp); });
    auxkey2 = ({ struct Tree* tmp = ({ struct Tree* tmp = p_node; (struct Tree*) tmp->vtable[5](tmp); }); (int) tmp->vtable[4](tmp); });
    if (({ struct Tree* tmp = this; (int) tmp->vtable[0](tmp, auxkey1, auxkey2); })) {
      ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[18](tmp, *((struct Tree**)((char*) this + 28))); });
      ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[15](tmp, 0); });
    }
    else {
      ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[19](tmp, *((struct Tree**)((char*) this + 28))); });
      ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[16](tmp, 0); });
    }
  }
  return (void*)(1);
}
void* Tree_RemoveLeft(struct Tree* this, struct Tree* p_node, struct Tree* c_node) {
  int ntb;
  while (({ struct Tree* tmp = c_node; (int) tmp->vtable[2](tmp); })) {
    ntb = ({ struct Tree* tmp = c_node; (int) tmp->vtable[17](tmp, ({ struct Tree* tmp = ({ struct Tree* tmp = c_node; (struct Tree*) tmp->vtable[5](tmp); }); (int) tmp->vtable[4](tmp); })); });
    p_node = c_node;
    c_node = ({ struct Tree* tmp = c_node; (struct Tree*) tmp->vtable[5](tmp); });
  }
  ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[18](tmp, *((struct Tree**)((char*) this + 28))); });
  ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[15](tmp, 0); });
  return (void*)(1);
}
void* Tree_RemoveRight(struct Tree* this, struct Tree* p_node, struct Tree* c_node) {
  int ntb;
  while (({ struct Tree* tmp = c_node; (int) tmp->vtable[3](tmp); })) {
    ntb = ({ struct Tree* tmp = c_node; (int) tmp->vtable[17](tmp, ({ struct Tree* tmp = ({ struct Tree* tmp = c_node; (struct Tree*) tmp->vtable[6](tmp); }); (int) tmp->vtable[4](tmp); })); });
    p_node = c_node;
    c_node = ({ struct Tree* tmp = c_node; (struct Tree*) tmp->vtable[6](tmp); });
  }
  ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[19](tmp, *((struct Tree**)((char*) this + 28))); });
  ntb = ({ struct Tree* tmp = p_node; (int) tmp->vtable[16](tmp, 0); });
  return (void*)(1);
}
void* Tree_Search(struct Tree* this, int v_key) {
  int cont;
  struct Tree* current_node;
  int ifound;
  int key_aux;
  current_node = this;
  cont = 1;
  ifound = 0;
  while (cont) {
    key_aux = ({ struct Tree* tmp = current_node; (int) tmp->vtable[4](tmp); });
    if ((v_key < key_aux)) if (({ struct Tree* tmp = current_node; (int) tmp->vtable[2](tmp); })) current_node = ({ struct Tree* tmp = current_node; (struct Tree*) tmp->vtable[5](tmp); });
    else cont = 0;
    else if ((key_aux < v_key)) if (({ struct Tree* tmp = current_node; (int) tmp->vtable[3](tmp); })) current_node = ({ struct Tree* tmp = current_node; (struct Tree*) tmp->vtable[6](tmp); });
    else cont = 0;
    else {
      ifound = 1;
      cont = 0;
    }
  }
  return (void*)(ifound);
}
void* Tree_SetHas_Left(struct Tree* this, int val) {
  *((int*)((char*) this + 8)) = val;
  return (void*)(1);
}
void* Tree_SetHas_Right(struct Tree* this, int val) {
  *((int*)((char*) this + 12)) = val;
  return (void*)(1);
}
void* Tree_SetKey(struct Tree* this, int v_key) {
  *((int*)((char*) this + 16)) = v_key;
  return (void*)(1);
}
void* Tree_SetLeft(struct Tree* this, struct Tree* ln) {
  *((struct Tree**)((char*) this + 20)) = ln;
  return (void*)(1);
}
void* Tree_SetRight(struct Tree* this, struct Tree* rn) {
  *((struct Tree**)((char*) this + 36)) = rn;
  return (void*)(1);
}
void* Tree_accept(struct Tree* this, struct Visitor* v) {
  int nti;
  printf("%d\n", 333);
  nti = ({ struct Visitor* tmp = v; (int) tmp->vtable[0](tmp, this); });
  return (void*)(0);
}
void* Visitor_visit(struct Visitor* this, struct Tree* n) {
  int nti;
  if (({ struct Tree* tmp = n; (int) tmp->vtable[3](tmp); })) {
    *((struct Tree**)((char*) this + 16)) = ({ struct Tree* tmp = n; (struct Tree*) tmp->vtable[6](tmp); });
    nti = ({ struct Tree* tmp = *((struct Tree**)((char*) this + 16)); (int) tmp->vtable[20](tmp, this); });
  }
  else nti = 0;
  if (({ struct Tree* tmp = n; (int) tmp->vtable[2](tmp); })) {
    *((struct Tree**)((char*) this + 8)) = ({ struct Tree* tmp = n; (struct Tree*) tmp->vtable[5](tmp); });
    nti = ({ struct Tree* tmp = *((struct Tree**)((char*) this + 8)); (int) tmp->vtable[20](tmp, this); });
  }
  else nti = 0;
  return (void*)(0);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct TV* tmp = ({ struct TV* tmp = (struct TV*) calloc(1, sizeof(*tmp)); tmp->vtable = TV_vtable; tmp; }); (int) tmp->vtable[0](tmp); }));
  return 0;
}

/*
class LinkedList {
  public static void main(String[] a) {
    System.out.println(new LL().Start());
  }
}
class Element {
  int Age;
  boolean Married;
  int Salary;
  public boolean Compare(int num1, int num2) {
    int aux02;
    boolean retval;
    retval = false;
    aux02 = num2 + 1;
    if (num1 < num2) retval = false;
    else if (!(num1 < aux02)) retval = false;
    else retval = true;
    return retval;
  }
  public boolean Equal(Element other) {
    int aux01;
    int aux02;
    int nt;
    boolean ret_val;
    ret_val = true;
    aux01 = other.GetAge();
    if (!this.Compare(aux01, Age)) ret_val = false;
    else {
      aux02 = other.GetSalary();
      if (!this.Compare(aux02, Salary)) ret_val = false;
      else if (Married) if (!other.GetMarried()) ret_val = false;
      else nt = 0;
      else if (other.GetMarried()) ret_val = false;
      else nt = 0;
    }
    return ret_val;
  }
  public int GetAge() {
    return Age;
  }
  public boolean GetMarried() {
    return Married;
  }
  public int GetSalary() {
    return Salary;
  }
  public boolean Init(int v_Age, int v_Salary, boolean v_Married) {
    Age = v_Age;
    Salary = v_Salary;
    Married = v_Married;
    return true;
  }
}
class LL {
  public int Start() {
    boolean aux01;
    Element el01;
    Element el02;
    Element el03;
    List head;
    List last_elem;
    last_elem = new List();
    aux01 = last_elem.Init();
    head = last_elem;
    aux01 = head.Init();
    aux01 = head.Print();
    el01 = new Element();
    aux01 = el01.Init(25, 37000, false);
    head = head.Insert(el01);
    aux01 = head.Print();
    System.out.println(10000000);
    el01 = new Element();
    aux01 = el01.Init(39, 42000, true);
    el02 = el01;
    head = head.Insert(el01);
    aux01 = head.Print();
    System.out.println(10000000);
    el01 = new Element();
    aux01 = el01.Init(22, 34000, false);
    head = head.Insert(el01);
    aux01 = head.Print();
    el03 = new Element();
    aux01 = el03.Init(27, 34000, false);
    System.out.println(head.Search(el02));
    System.out.println(head.Search(el03));
    System.out.println(10000000);
    el01 = new Element();
    aux01 = el01.Init(28, 35000, false);
    head = head.Insert(el01);
    aux01 = head.Print();
    System.out.println(2220000);
    head = head.Delete(el02);
    aux01 = head.Print();
    System.out.println(33300000);
    head = head.Delete(el01);
    aux01 = head.Print();
    System.out.println(44440000);
    return 0;
  }
}
class List {
  Element elem;
  boolean end;
  List next;
  public List Delete(Element e) {
    List aux01;
    int aux04;
    boolean aux05;
    List my_head;
    int nt;
    List prev;
    boolean ret_val;
    Element var_elem;
    boolean var_end;
    my_head = this;
    ret_val = false;
    aux04 = 0 - 1;
    aux01 = this;
    prev = this;
    var_end = end;
    var_elem = elem;
    while (!var_end && !ret_val) {
      if (e.Equal(var_elem)) {
        ret_val = true;
        if (aux04 < 0) {
          my_head = aux01.GetNext();
        }
        else {
          System.out.println(0 - 555);
          aux05 = prev.SetNext(aux01.GetNext());
          System.out.println(0 - 555);
        }
      }
      else nt = 0;
      if (!ret_val) {
        prev = aux01;
        aux01 = aux01.GetNext();
        var_end = aux01.GetEnd();
        var_elem = aux01.GetElem();
        aux04 = 1;
      }
      else nt = 0;
    }
    return my_head;
  }
  public Element GetElem() {
    return elem;
  }
  public boolean GetEnd() {
    return end;
  }
  public List GetNext() {
    return next;
  }
  public boolean Init() {
    end = true;
    return true;
  }
  public boolean InitNew(Element v_elem, List v_next, boolean v_end) {
    end = v_end;
    elem = v_elem;
    next = v_next;
    return true;
  }
  public List Insert(Element new_elem) {
    List aux02;
    List aux03;
    boolean ret_val;
    aux03 = this;
    aux02 = new List();
    ret_val = aux02.InitNew(new_elem, aux03, false);
    return aux02;
  }
  public boolean Print() {
    List aux01;
    Element var_elem;
    boolean var_end;
    aux01 = this;
    var_end = end;
    var_elem = elem;
    while (!var_end) {
      System.out.println(var_elem.GetAge());
      aux01 = aux01.GetNext();
      var_end = aux01.GetEnd();
      var_elem = aux01.GetElem();
    }
    return true;
  }
  public int Search(Element e) {
    List aux01;
    int int_ret_val;
    int nt;
    Element var_elem;
    boolean var_end;
    int_ret_val = 0;
    aux01 = this;
    var_end = end;
    var_elem = elem;
    while (!var_end) {
      if (e.Equal(var_elem)) {
        int_ret_val = 1;
      }
      else nt = 0;
      aux01 = aux01.GetNext();
      var_end = aux01.GetEnd();
      var_elem = aux01.GetElem();
    }
    return int_ret_val;
  }
  public boolean SetNext(List v_next) {
    next = v_next;
    return true;
  }
}
*/
#include <stdio.h>
#include <stdlib.h>
#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
struct array { int* array; int length; };
struct Element;
struct LL;
struct List;
void* Element_Compare(struct Element* this, int num1, int num2);
void* Element_Equal(struct Element* this, struct Element* other);
void* Element_GetAge(struct Element* this);
void* Element_GetMarried(struct Element* this);
void* Element_GetSalary(struct Element* this);
void* Element_Init(struct Element* this, int v_Age, int v_Salary, int v_Married);
void* LL_Start(struct LL* this);
void* List_Delete(struct List* this, struct Element* e);
void* List_GetElem(struct List* this);
void* List_GetEnd(struct List* this);
void* List_GetNext(struct List* this);
void* List_Init(struct List* this);
void* List_InitNew(struct List* this, struct Element* v_elem, struct List* v_next, int v_end);
void* List_Insert(struct List* this, struct Element* new_elem);
void* List_Print(struct List* this);
void* List_Search(struct List* this, struct Element* e);
void* List_SetNext(struct List* this, struct List* v_next);
struct Element {
  void* (**vtable)();
  int _1;
  int _2;
  int _3;
};
struct LL {
  void* (**vtable)();
};
struct List {
  void* (**vtable)();
  struct Element* _1;
  int _2;
  struct List* _3;
};
void* (*Element_vtable[])() = {Element_Compare, Element_Equal, Element_GetAge, Element_GetMarried, Element_GetSalary, Element_Init};
void* (*LL_vtable[])() = {LL_Start};
void* (*List_vtable[])() = {List_Delete, List_GetElem, List_GetEnd, List_GetNext, List_Init, List_InitNew, List_Insert, List_Print, List_Search, List_SetNext};
void* Element_Compare(struct Element* this, int num1, int num2) {
  int aux02;
  int retval;
  retval = 0;
  aux02 = (num2 + 1);
  if ((num1 < num2)) retval = 0;
  else if (!((num1 < aux02))) retval = 0;
  else retval = 1;
  return (void*)(retval);
}
void* Element_Equal(struct Element* this, struct Element* other) {
  int aux01;
  int aux02;
  int nt;
  int ret_val;
  ret_val = 1;
  aux01 = ({ struct Element* tmp = other; (int) tmp->vtable[2](tmp); });
  if (!(({ struct Element* tmp = this; (int) tmp->vtable[0](tmp, aux01, *((int*)((char*) this + 8))); }))) ret_val = 0;
  else {
    aux02 = ({ struct Element* tmp = other; (int) tmp->vtable[4](tmp); });
    if (!(({ struct Element* tmp = this; (int) tmp->vtable[0](tmp, aux02, *((int*)((char*) this + 16))); }))) ret_val = 0;
    else if (*((int*)((char*) this + 12))) if (!(({ struct Element* tmp = other; (int) tmp->vtable[3](tmp); }))) ret_val = 0;
    else nt = 0;
    else if (({ struct Element* tmp = other; (int) tmp->vtable[3](tmp); })) ret_val = 0;
    else nt = 0;
  }
  return (void*)(ret_val);
}
void* Element_GetAge(struct Element* this) {
  return (void*)(*((int*)((char*) this + 8)));
}
void* Element_GetMarried(struct Element* this) {
  return (void*)(*((int*)((char*) this + 12)));
}
void* Element_GetSalary(struct Element* this) {
  return (void*)(*((int*)((char*) this + 16)));
}
void* Element_Init(struct Element* this, int v_Age, int v_Salary, int v_Married) {
  *((int*)((char*) this + 8)) = v_Age;
  *((int*)((char*) this + 16)) = v_Salary;
  *((int*)((char*) this + 12)) = v_Married;
  return (void*)(1);
}
void* LL_Start(struct LL* this) {
  int aux01;
  struct Element* el01;
  struct Element* el02;
  struct Element* el03;
  struct List* head;
  struct List* last_elem;
  last_elem = ({ struct List* tmp = (struct List*) calloc(1, sizeof(*tmp)); tmp->vtable = List_vtable; tmp; });
  aux01 = ({ struct List* tmp = last_elem; (int) tmp->vtable[4](tmp); });
  head = last_elem;
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[4](tmp); });
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[7](tmp); });
  el01 = ({ struct Element* tmp = (struct Element*) calloc(1, sizeof(*tmp)); tmp->vtable = Element_vtable; tmp; });
  aux01 = ({ struct Element* tmp = el01; (int) tmp->vtable[5](tmp, 25, 37000, 0); });
  head = ({ struct List* tmp = head; (struct List*) tmp->vtable[6](tmp, el01); });
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[7](tmp); });
  printf("%d\n", 10000000);
  el01 = ({ struct Element* tmp = (struct Element*) calloc(1, sizeof(*tmp)); tmp->vtable = Element_vtable; tmp; });
  aux01 = ({ struct Element* tmp = el01; (int) tmp->vtable[5](tmp, 39, 42000, 1); });
  el02 = el01;
  head = ({ struct List* tmp = head; (struct List*) tmp->vtable[6](tmp, el01); });
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[7](tmp); });
  printf("%d\n", 10000000);
  el01 = ({ struct Element* tmp = (struct Element*) calloc(1, sizeof(*tmp)); tmp->vtable = Element_vtable; tmp; });
  aux01 = ({ struct Element* tmp = el01; (int) tmp->vtable[5](tmp, 22, 34000, 0); });
  head = ({ struct List* tmp = head; (struct List*) tmp->vtable[6](tmp, el01); });
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[7](tmp); });
  el03 = ({ struct Element* tmp = (struct Element*) calloc(1, sizeof(*tmp)); tmp->vtable = Element_vtable; tmp; });
  aux01 = ({ struct Element* tmp = el03; (int) tmp->vtable[5](tmp, 27, 34000, 0); });
  printf("%d\n", ({ struct List* tmp = head; (int) tmp->vtable[8](tmp, el02); }));
  printf("%d\n", ({ struct List* tmp = head; (int) tmp->vtable[8](tmp, el03); }));
  printf("%d\n", 10000000);
  el01 = ({ struct Element* tmp = (struct Element*) calloc(1, sizeof(*tmp)); tmp->vtable = Element_vtable; tmp; });
  aux01 = ({ struct Element* tmp = el01; (int) tmp->vtable[5](tmp, 28, 35000, 0); });
  head = ({ struct List* tmp = head; (struct List*) tmp->vtable[6](tmp, el01); });
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[7](tmp); });
  printf("%d\n", 2220000);
  head = ({ struct List* tmp = head; (struct List*) tmp->vtable[0](tmp, el02); });
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[7](tmp); });
  printf("%d\n", 33300000);
  head = ({ struct List* tmp = head; (struct List*) tmp->vtable[0](tmp, el01); });
  aux01 = ({ struct List* tmp = head; (int) tmp->vtable[7](tmp); });
  printf("%d\n", 44440000);
  return (void*)(0);
}
void* List_Delete(struct List* this, struct Element* e) {
  struct List* aux01;
  int aux04;
  int aux05;
  struct List* my_head;
  int nt;
  struct List* prev;
  int ret_val;
  struct Element* var_elem;
  int var_end;
  my_head = this;
  ret_val = 0;
  aux04 = (0 - 1);
  aux01 = this;
  prev = this;
  var_end = *((int*)((char*) this + 16));
  var_elem = *((struct Element**)((char*) this + 8));
  while ((!(var_end) && !(ret_val))) {
    if (({ struct Element* tmp = e; (int) tmp->vtable[1](tmp, var_elem); })) {
      ret_val = 1;
      if ((aux04 < 0)) {
        my_head = ({ struct List* tmp = aux01; (struct List*) tmp->vtable[3](tmp); });
      }
      else {
        printf("%d\n", (0 - 555));
        aux05 = ({ struct List* tmp = prev; (int) tmp->vtable[9](tmp, ({ struct List* tmp = aux01; (struct List*) tmp->vtable[3](tmp); })); });
        printf("%d\n", (0 - 555));
      }
    }
    else nt = 0;
    if (!(ret_val)) {
      prev = aux01;
      aux01 = ({ struct List* tmp = aux01; (struct List*) tmp->vtable[3](tmp); });
      var_end = ({ struct List* tmp = aux01; (int) tmp->vtable[2](tmp); });
      var_elem = ({ struct List* tmp = aux01; (struct Element*) tmp->vtable[1](tmp); });
      aux04 = 1;
    }
    else nt = 0;
  }
  return (void*)(my_head);
}
void* List_GetElem(struct List* this) {
  return (void*)(*((struct Element**)((char*) this + 8)));
}
void* List_GetEnd(struct List* this) {
  return (void*)(*((int*)((char*) this + 16)));
}
void* List_GetNext(struct List* this) {
  return (void*)(*((struct List**)((char*) this + 20)));
}
void* List_Init(struct List* this) {
  *((int*)((char*) this + 16)) = 1;
  return (void*)(1);
}
void* List_InitNew(struct List* this, struct Element* v_elem, struct List* v_next, int v_end) {
  *((int*)((char*) this + 16)) = v_end;
  *((struct Element**)((char*) this + 8)) = v_elem;
  *((struct List**)((char*) this + 20)) = v_next;
  return (void*)(1);
}
void* List_Insert(struct List* this, struct Element* new_elem) {
  struct List* aux02;
  struct List* aux03;
  int ret_val;
  aux03 = this;
  aux02 = ({ struct List* tmp = (struct List*) calloc(1, sizeof(*tmp)); tmp->vtable = List_vtable; tmp; });
  ret_val = ({ struct List* tmp = aux02; (int) tmp->vtable[5](tmp, new_elem, aux03, 0); });
  return (void*)(aux02);
}
void* List_Print(struct List* this) {
  struct List* aux01;
  struct Element* var_elem;
  int var_end;
  aux01 = this;
  var_end = *((int*)((char*) this + 16));
  var_elem = *((struct Element**)((char*) this + 8));
  while (!(var_end)) {
    printf("%d\n", ({ struct Element* tmp = var_elem; (int) tmp->vtable[2](tmp); }));
    aux01 = ({ struct List* tmp = aux01; (struct List*) tmp->vtable[3](tmp); });
    var_end = ({ struct List* tmp = aux01; (int) tmp->vtable[2](tmp); });
    var_elem = ({ struct List* tmp = aux01; (struct Element*) tmp->vtable[1](tmp); });
  }
  return (void*)(1);
}
void* List_Search(struct List* this, struct Element* e) {
  struct List* aux01;
  int int_ret_val;
  int nt;
  struct Element* var_elem;
  int var_end;
  int_ret_val = 0;
  aux01 = this;
  var_end = *((int*)((char*) this + 16));
  var_elem = *((struct Element**)((char*) this + 8));
  while (!(var_end)) {
    if (({ struct Element* tmp = e; (int) tmp->vtable[1](tmp, var_elem); })) {
      int_ret_val = 1;
    }
    else nt = 0;
    aux01 = ({ struct List* tmp = aux01; (struct List*) tmp->vtable[3](tmp); });
    var_end = ({ struct List* tmp = aux01; (int) tmp->vtable[2](tmp); });
    var_elem = ({ struct List* tmp = aux01; (struct Element*) tmp->vtable[1](tmp); });
  }
  return (void*)(int_ret_val);
}
void* List_SetNext(struct List* this, struct List* v_next) {
  *((struct List**)((char*) this + 20)) = v_next;
  return (void*)(1);
}
int main(int argc, char *argv[]) {
  printf("%d\n", ({ struct LL* tmp = ({ struct LL* tmp = (struct LL*) calloc(1, sizeof(*tmp)); tmp->vtable = LL_vtable; tmp; }); (int) tmp->vtable[0](tmp); }));
  return 0;
}
